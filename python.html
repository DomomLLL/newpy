<html>
<head>
  <title>python小笔记：模块化开发，文件管理系统，异常问题，装饰器，面向对象</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/600363 (zh-CN, DDL); Windows/6.1.1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="428"/>
<h1>python小笔记：模块化开发，文件管理系统，异常问题，装饰器，面向对象</h1>

<div>
<span><div><font style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(255, 0, 0);">模块化开发</span></font></div><div><span style="font-size: 16pt;">import 导入模块(类或者方法)</span></div><div><span style="font-size: 16pt;">dir()查看有哪些属性和方法：</span><span style="font-size: 16pt;">内置属性，内置方法 例如：__name__</span></div><div><span style="font-size: 21.3333px;">模块的优化(提高编译速度)：python -m </span><span style="font-size: 21.3333px;">py _compile 生成编译文件</span></div><div><span style="font-size: 16pt;">导入模块前，原模块中有不需要在其他地方执行的代码前加上</span></div><div><span style="font-size: 21.3333px;">     </span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 16pt;">if __name__ ==&quot;__main__&quot;:</span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 21.3333px;">匿名函数：lambda 快速定义单行的最小函数</span></div><div><span style="font-size: 21.3333px;">例子：</span></div><div><span style="font-size: 21.3333px;">        filter(f,l)根据f函数过滤l的内容f只给filter使用的时候可以用匿名函数</span></div><div><span style="font-size: 21.3333px;">       </span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 16pt;">filter(lambda x : x % 3 == 0,[1, 3, 5, 6, 7])</span></div></div><div><br/></div><div><span style="font-size: 21.3333px;">  过滤函数中，指定过滤列表元素</span></div><div><span style="font-size: 21.3333px;">        map函数中，指定对列表中每一个元素的共同操作</span></div><div><span style="font-size: 21.3333px;">        </span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 16pt;">map(lambda x: x+1, [1, 2, 3]) ---&gt;[2, 3, 4]</span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 21.3333px;">zip 遍历序列</span></div><div><span style="font-size: 21.3333px;">     </span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 16pt;">l1 = [1, 2, 3]</span></div><div><span style="font-size: 16pt;">      l2 = [4, 5, 6]</span></div><div><span style="font-size: 16pt;">      zip(l1,l2)</span></div><div><span style="font-size: 16pt;">      for i in zip(l1, l2)</span></div><div><span style="font-size: 16pt;">            print(i) ----&gt;(1, 4)</span></div><div><span style="font-size: 16pt;">                          (2, 5)</span></div><div><span style="font-size: 16pt;">                          (3, 6)</span></div><div><span style="font-size: 16pt;">      dict(zip(l1, l2))---&gt;{1: 4, 2: 5, 3: 6}</span></div></div><div><br/></div><div><span style="font-size: 16pt;">enumerate</span></div><div><span style="font-size: 16pt;">与zip功能比较像</span></div><div><span style="font-size: 16pt;">对可迭代对象里的每一个元素，配上一个索引，然后索引和内容构成tuple类型</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 16pt;">#enumerate案例一</span></div><div><span style="font-size: 16pt;">l1 = [11,22,33,44,55]</span></div><div><span style="font-size: 16pt;">em = enumerate(l1)</span></div><div><span style="font-size: 16pt;">l2 = [i for i in em]</span></div><div><span style="font-size: 16pt;">print(l2)</span></div><div><span style="font-size: 16pt;">[(0,11), (1,22), (2,33), (3,44), (4,55)]</span></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 16pt; color: rgb(235, 0, 115);">#案例二</span></div><div><span style="font-size: 16pt; color: rgb(235, 0, 115);">em = enumerate(l1, start = 100)</span></div><div><span style="font-size: 16pt; color: rgb(235, 0, 115);">l2 = [i for i in em]</span></div><div><span style="font-size: 16pt; color: rgb(235, 0, 115);">print(l2)</span></div><div><span style="font-size: 16pt; color: rgb(235, 0, 115);">[(100, 11), (101, 22), (102, 33), (103, 44), (104, 55)]</span></div></div><div><span style="font-size: 21.3333px;"><span style="font-size: 21.3333px; color: rgb(235, 0, 115);">文件管理系统</span></span></div><div><span style="font-size: 16pt;">import os</span></div><div><span style="font-size: 16pt;">os.path.abspath() 显示绝对路径</span></div><div><span style="font-size: 16pt;">os.getcwd()获取当前路径</span></div><div><span style="font-size: 16pt;">os.listdir(path)获取文件列表</span></div><div><span style="font-size: 16pt;">os.mkdir(path)创建目录</span></div><div><span style="font-size: 16pt;">os.rmdir()删除目录</span></div><div><span style="font-size: 16pt;">os.path.isdir(path)判断是否为目录</span></div><div><span style="font-size: 16pt;">os.path.isfile(path)判断是否为文件</span></div><div><span style="font-size: 16pt;">os.walk()遍历</span></div><div><span style="font-size: 16pt;">import sys</span></div><div><span style="font-size: 16pt;">sys.argv[1]   在python后加上要调用的路径</span></div><div><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(255, 0, 0);">异常问题：</span></span></div><div><span style="font-size: 16pt;">1.捕获异常</span></div><div><span style="font-size: 16pt;">    try:</span></div><div><span style="font-size: 16pt;">         指令</span></div><div><span style="font-size: 16pt;">    except 异常名字 as e：(捕获异常)</span></div><div><span style="font-size: 16pt;">         指令</span></div><div><span style="font-size: 16pt;">         print(&quot;no name&quot;,e)</span></div><div><span style="font-size: 16pt;">    else:(没有发现异常时执行)</span></div><div><span style="font-size: 16pt;">           指令</span></div><div><span style="font-size: 16pt;">    try：</span></div><div><span style="font-size: 16pt;">          指令</span></div><div><span style="font-size: 16pt;">    finally：(不管有没有发生异常都执行)</span></div><div><span style="font-size: 16pt;">2.抛出异常</span></div><div><span style="font-size: 16pt;">         raise 异常名（提示）</span></div><div><span style="font-size: 16pt;">3.可能出现的异常：</span></div><div><span style="font-size: 16pt;">        <span style="font-size: 16pt;">BaseError:基本类</span></span></div><div><span style="font-size: 16pt;">        SyntaxError：语法错误(当导入模块时，模块有语法问题时可以抛出)</span></div><div><span style="font-size: 16pt;">        NameError：变量没有定义</span></div><div><span style="font-size: 16pt;">        TypeError:类型错误</span></div><div><span style="font-size: 16pt;">        ValueError:</span></div><div><span style="font-size: 16pt;">        IndexError：索引错误</span></div><div><span style="font-size: 16pt;">        Indexerror索引异常</span></div><div><span style="font-size: 16pt;">        FileNotFound 文件不存在</span></div><div><br/></div><div><span style="font-size: 16pt;">避免代码的重复</span></div><div><span style="font-size: 16pt;">    闭包(特殊的函数)：有内嵌函数，获取上层函数的变量，返回内嵌函数</span></div><div><span style="font-size: 16pt;">    装饰器(特殊的闭包)：装饰器中定义一个新的函数，返回一个新的功能</span></div><div><span style="font-size: 16pt;">    语法糖：用@调用函数 功能等于装饰器</span></div><div><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(255, 0, 0);">内置装饰器</span>(都是再定义方法前加)：1.@staticmethod：可以调用类名，不需要实例化，类静态方法（只有类可以使用不需要self）常驻内存</span></div><div><span style="font-size: 16pt;">                    2.@classmethod：可以通过cls（）调用类，类方法(谁调用self，self就是谁)动态加载内存</span></div><div><span style="font-size: 16pt;">                    3.@property：属性方法(把一个方法变成一个属性) help(property)</span></div><div><span style="font-size: 16pt;">                       </span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 16pt;">方法一：<span style="font-size: 16pt; font-family: Monaco; color: rgb(51, 51, 51);">直接再函数前加@property</span></span></div><div><span style="font-size: 16pt;"><span>    </span><span>   <span style="font-size: 16pt; font-family: Monaco; color: rgb(51, 51, 51);">@</span>property</span></span></div><div><span style="font-size: 16pt;"><span>    </span><span>  </span> def x(self):</span></div><div><span style="font-size: 16pt;">           pass</span></div><div><span style="font-size: 16pt;">       @x.setter</span></div><div><span style="font-size: 16pt;">       def x(self):</span></div><div><span style="font-size: 16pt;">           pass</span></div><div><span style="font-size: 16pt;">       @x.deleter</span></div><div><span style="font-size: 16pt;">       def x(self):</span></div><div><span style="font-size: 16pt;">           pass</span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 16pt;">                     </span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 16pt;">   方法二：</span></div><div><span style="font-size: 16pt;">        def setx(self):</span></div><div><span style="font-size: 16pt;">            pass</span></div><div><span style="font-size: 16pt;">        def getx(self):</span></div><div><span style="font-size: 16pt;">            </span><span style="font-size: 16pt;">pass</span></div><div><span style="font-size: 16pt;">         def delx(self):</span></div><div><span style="font-size: 16pt;">            pass</span></div><div><span style="font-size: 16pt;">         x = property(setx, getx,</span><span style="font-size: 16pt;">delx) </span></div><div><br/></div></div><div><br/></div><div><br/></div><div><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(255, 0, 0);">面向对象</span></span></div><div><span style="font-size: 16pt;">python的类抽象化的方法和属性的集合</span></div><div><span style="font-size: 16pt;">     属性：公有属性（类属性）：可以被类和对象直接调用</span></div><div><span style="font-size: 16pt;">               内置属性:__name__ 不需要自己设置</span></div><div><span style="font-size: 16pt;">               私有属性：__类的内部可以实现类的封装，通过类中的定义方法调用私有属性</span></div><div><span style="font-size: 16pt;">    方法：公有(对象的方法)方法不能直接被类调用 但是可以通过装饰器装饰成类方法</span></div><div><span style="font-size: 16pt;">               私有__:内部实现 对象可以根据公有方法调用</span></div><div><span style="font-size: 16pt;">               内置方法（魔术方法）</span></div><div><span style="font-size: 16pt;">               __init__,__del__,__add__</span></div><div><span style="font-size: 16pt;">              在公有属性和方法中直接赋值取值有魔术方法setter，getter方法不用调用会自动调用</span></div><div><span style="font-size: 16pt;">实例化对象：对象可以调用属性和方法</span></div><div><span style="font-size: 16pt;">使用点记法访问   对象.方法()</span></div><div><span style="font-size: 16pt;">类中定义的属性是局部的 </span></div><div><span style="font-size: 16pt;">class 大驼峰命名():</span></div><div><span style="font-size: 16pt;">     属性</span></div><div><span style="font-size: 16pt;">     def 小驼峰(self):(方法)</span></div><div><span style="font-size: 16pt;">如果希望创建的对象可以自定义一个初始状态可以用__init__()实例化对象时 自动调用init中的属性必须实例化才可以用或者可以在init定义的时候设定初始的值</span></div><div><span style="font-size: 16pt;">class Myclass():</span></div><div><span style="font-size: 16pt;">     var1 =   &quot;类属性，也叫静态属性&quot;</span></div><div><span style="font-size: 16pt;">      __var2 = &quot;&quot;   类的私有属性</span></div><div><span style="font-size: 16pt;">      def __init__(self):</span></div><div><span style="font-size: 16pt;">             self.var2 = var2  是实例化的属性</span></div><div><span style="font-size: 16pt;">             self.__var3 =    &quot;实例的私有属性&quot;</span></div><div><span style="font-size: 16pt;">             var4 = &quot;简单变量，非属性，作用域只在函数体内&quot;</span></div><div><br/></div><div><span style="font-size: 16pt;"><span style="font-size: 16pt; color: rgb(255, 0, 0);">面向对象的特点： 封装，继承，多态</span></span></div><div><span style="font-size: 16pt;"> 封装：将对象当中所有的属性和方法封装到一个类中</span></div><div><span style="font-size: 16pt;">继承：继承父类的公有属性和公有方法</span></div><div><span style="font-size: 16pt;">          可以多继承，多个父类继承有同一属性或方法时以继承第一个父类的属性和方法</span></div><div>                   <span style="font-size: 16pt;">有继承</span>  <span style="font-size: 16pt;">就会产生重载</span></div><div><span style="font-size: 16pt;">                    重载：可以重新定义父类的公有或公有属性，还可以定义新的属性和方法</span></div><div><span style="font-size: 16pt;">强制调用父类的方法和属性(Father.)</span></div><div><span style="font-size: 16pt;">    经典类：父类.方法(self) 先左后右深度遍历    </span></div><div>       <span style="font-size: 16pt;">新式类：super(当前类，self).方法()  层次调用</span></div><div><span style="font-size: 16pt;">在二的版本中（object）</span></div><div><span style="font-size: 16pt;">调试：</span></div><div><span style="font-size: 16pt;">    assert 表达式[参数] 测试异常   如果没有异常不输出任何东西</span></div><div><span style="font-size: 16pt;">结对编程</span></div><div><span style="font-size: 16pt;">TDD(测试驱动开发)</span></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br/></div></div><div><br/></div></span>
</div></body></html> 